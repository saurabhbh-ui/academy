payload:


{
  "artifact": {
    "content": "string"
  },
  "brief_instructions": {
    "title": "string",
    "objectives": "string",
    "overview": "string",
    "content": "string"
  }
}



Schemas: 
import enum
import logging
from typing import List, Optional, Union

from humps import camelize
from openai.types.chat import ChatCompletionRole
from pydantic import BaseModel as PydanticBaseModel
from pydantic import ConfigDict, Field, model_validator
from typing_extensions import Literal, TypeAlias

logger = logging.getLogger(__name__)


class BaseModel(PydanticBaseModel):
    model_config = ConfigDict(alias_generator=camelize, populate_by_name=True, use_enum_values=True)


# ---------------------------------  Enums ---------------------------------- #
# --------------------------------------------------------------------------- #


@enum.unique
class TutorialSuiteStage(str, enum.Enum):
    outline = "outline"
    brief = "brief"
    test_yourself = "test_yourself"
    connect = "connect"
    exsum = "exsum"


@enum.unique
class BriefCount(str, enum.Enum):
    one = "one"
    two = "two"
    three = "three"
    four = "four"
    five = "five"

    __NUMERIC_MAP__ = {
        "one": 1,
        "two": 2,
        "three": 3,
        "four": 4,
        "five": 5,
    }

    def to_numeric(self):
        return self.__NUMERIC_MAP__[self.value]


@enum.unique
class Tone(str, enum.Enum):
    basic = "basic"
    intermediate = "intermediate"
    advanced = "advanced"


@enum.unique
class SpecialisedTone(str, enum.Enum):
    simple_and_clear = "simple_and_clear"
    professional_and_concise = "professional_and_concise"
    engaging_and_conversational = "engaging_and_conversational"
    explanatory_and_visual = "explanatory_and_visual"
    scenario_based_and_practical = "scenario_based_and_practical"
    technical_and_analytical = "technical_and_analytical"
    step_by_step_instructional = "step_by_step_instructional"
    comparative_and_contextual = "comparative_and_contextual"
    encouraging_and_motivational = "encouraging_and_motivational"
    interactive_and_question_oriented = "interactive_and_question_oriented"

    __PROMPT_MAP__ = {
        "simple_and_clear": "The tone of each brief should emphasize plain language, avoid jargon, and explain complex concept with relatable examples. The target audience is entry-level.",
        "professional_and_concise": "Each brief should use a formal and precise approach with minimal elaboration. The target audience is technical specialists.",
        "engaging_and_conversational": "Each brief should create a welcoming atmosphere and encourages participation.",
        "explanatory_and_visual": "Each brief should break down concepts into manageable parts to bridge knowledge gaps.",
        "scenario_based_and_practical": "The breifs should focus on real-world applications to enhance understanding.",
        "technical_and_analytical": "In-depth explanations with data and advanced terminology.",
        "step_by_step_instructional": "Guides through processes or calculations.",
        "comparative_and_contextual": "Each brief should explain international standards in comparison to regional practices or historical trends.",
        "encouraging_and_motivational": "Each brief should emphasize the importance of the role of the trainee and build their confidence.",
        "interactive_and_question_oriented": "Each brief should engage the audience by prompting critical thinking and self-reflection.",
    }

    def to_prompt_statement(self) -> str:
        return self.__PROMPT_MAP__[self.value]


@enum.unique
class NewLevel(str, enum.Enum):
    beginner = "Beginner"
    intermediate = "Intermediate"
    advanced = "Advanced"


@enum.unique
class NewLength(str, enum.Enum):
    shortest = "shortest"
    shorter = "shorter"
    longer = "longer"
    longest = "longest"

    __PROMPT_MAP__ = {
        "shortest": "much shorter than it currently is",
        "shorter": "slightly shorter than it currently is",
        "longer": "slightly longer than it currently is",
        "longest": "much longer than it currently is",
    }

    def to_prompt_value(self) -> str:
        return self.__PROMPT_MAP__[self.value]


@enum.unique
class EventType(str, enum.Enum):
    on_rewrite_block = "on_rewrite_block"
    on_rewrite_artifact = "on_rewrite_artifact"
    on_chat_response = "on_chat_response"
    on_progress_update = "on_progress_update"


# ----------------------- Document & Artifact Models ------------------------ #
# --------------------------------------------------------------------------- #


class Figure(BaseModel):
    id: str
    b64image: str
    caption: Optional[str]
    footnote: Optional[str]
    page_number: int


class SourceDocument(BaseModel):
    file_type: str = ".pdf"
    content: str
    figures: list[Figure]


class TutorialConfiguration(BaseModel):
    model_config = ConfigDict(alias_generator=camelize, populate_by_name=True, use_enum_values=False)

    title: Optional[str]
    tone: Optional[SpecialisedTone]
    brief_count: BriefCount
    sections_to_highlight: Optional[str] = None
    sections_to_exclude: Optional[str] = None


class Artifact(BaseModel):
    content: str


class ArtifactChunk(BaseModel):
    block: str
    selection: str


class DocName(BaseModel):
    header_title: str = Field(default="No title", description="Document name or should be main title of the document")


# --------------------------- Event Stream Models --------------------------- #
# --------------------------------------------------------------------------- #


class StreamingEvent(BaseModel):
    event: EventType
    chunk: str


# ------------------------------- Brief Models ------------------------------ #
# --------------------------------------------------------------------------- #


class BriefInstructions(BaseModel):
    title: str = Field(description="The title of the brief, found in the '##' heading.")
    objectives: str = Field(
        description='The objectives of the brief, found in the paragraph starting with "**Objectives**" right after the heading. This is typically a single line, but could also be on several lines or a short bulleted list.'
    )
    overview: str = Field(
        description='The overview of the brief, found in the paragraph starting with "**Overview**", typically after the objectives.'
    )
    content: str = Field(
        description='The content of the brief, found in the paragraph starting with "**Content**", typically after the overview. This is is typically a long bulleted list.'
    )


class ParsedOutline(BaseModel):
    briefs: list[BriefInstructions] = Field(..., min_length=1)


# ----------------------- Refinement Request Models ------------------------- #
# --------------------------------------------------------------------------- #

# Create an extended role type to handle the error messages from the backend
ExtendedChatCompletionRole: TypeAlias = Union[ChatCompletionRole, Literal["error"]]


class ChatMessage(BaseModel):
    role: ExtendedChatCompletionRole
    content: str


class BaseRefinementRequest(BaseModel):
    messages: list[ChatMessage]
    artifact: str
    source: Union[SourceDocument, list[SourceDocument]]  # Updated to support both single and multiple documents

    @model_validator(mode="before")
    @classmethod
    def filter_error_messages(cls, data: dict[str, any]) -> dict[str, any]:
        if "messages" in data:
            len_before = len(data["messages"])

            # Filter out messages with role "error"
            data["messages"] = [
                msg for msg in data["messages"] if not (isinstance(msg, dict) and msg.get("role") == "error")
            ]

            len_after = len(data["messages"])
            if len_after < len_before:
                logger.info(f"Filtered {len_before - len_after} error messages")
        return data


class ChatCompletionRequest(BaseRefinementRequest):
    stage: TutorialSuiteStage
    config: Optional[TutorialConfiguration] = None
    brief_instructions: Optional[BriefInstructions] = None
    # source: Union[SourceDocument, list[SourceDocument]]  # Updated to support multiple documents

    @model_validator(mode="after")
    def validate_stage_requirements(self) -> "ChatCompletionRequest":
        """
        The optional `config` and `brief_instructions` are required depending on the stage.
        This validator checks that they are provided for each possible stage.
        """
        match self.stage:
            case TutorialSuiteStage.outline:
                # For outline stage, config must be provided
                if self.config is None:
                    raise ValueError("config is required for the 'outline' stage")

            # For brief stage, brief_instructions must be provided
            case TutorialSuiteStage.brief:
                if self.brief_instructions is None:
                    raise ValueError("brief_instructions is required for the 'brief' stage")

            case _:
                if (self.brief_instructions is not None) or (self.config is not None):
                    stage = self.stage
                    raise ValueError(f"brief_instructions and config should NOT be provided for the '{stage}' stage")

        return self


class AdjusLengthRequest(BaseRefinementRequest):
    model_config = ConfigDict(alias_generator=camelize, populate_by_name=True, use_enum_values=False)
    new_length: NewLength


class AdjustLevelRequest(BaseRefinementRequest):
    model_config = ConfigDict(alias_generator=camelize, populate_by_name=True, use_enum_values=False)
    new_level: NewLevel


class UpdateSelectionRequest(BaseModel):
    messages: list[ChatMessage]
    source: Union[SourceDocument, list[SourceDocument]]
    artifact_chunk: ArtifactChunk
    query: str


# ------------------------- Complex Response Models-------------------------- #
# --------------------------------------------------------------------------- #


class ArtifactWithResponse(Artifact):
    response: Optional[ChatMessage]


# ------------------------------ Connect Models ----------------------------- #
# --------------------------------------------------------------------------- #


class ConnectConfig(BaseModel):
    role: Optional[str] = Field(
        default=None,
        description="Professional role the learner assumes in the scenario. Can specify 'other' or any custom role.",
    )
    department: Optional[str] = Field(
        default=None,
        description="Functional department where the scenario is set. Can specify 'other' or any custom department.",
    )
    country_type: Optional[List[str]] = Field(
        default=None, description="Classification of the country. Can specify 'other' or any custom type."
    )
    authority_type: Optional[List[str]] = Field(
        default=None,
        description="Type of regulatory or supervisory authority involved. Can specify 'other' or any custom type.",
    )
    financial_institution: Optional[List[str]] = Field(
        default=None,
        description="The kind of financial institution featured. Can specify 'other' or any custom institution.",
    )
    artefacts: Optional[List[str]] = Field(
        default=None, description="Scenario information sources. Can specify 'other' or any custom sources."
    )
    characters: Optional[List[str]] = Field(
        default=None, description="Fictional characters in the scenario. Can specify 'other' or any custom characters."
    )
    scenario_description: Optional[str] = Field(
        default=None,
        description="A brief narrative outlining the context or background of the scenario. It sets the stage for the learner by describing the situation they will address.",
    )
    keypoints: Optional[List[str]] = Field(default=None, description="Key tasks the learner must perform.")
    task_examples: Optional[str] = Field(default=None, description="Example tasks shaping the scenario.")
    questions: Optional[List[Literal["Fill-in-the-Blank", "Multiple Choice Question", "True/False", "Yes/No"]]] = Field(
        default=None,
        description="Types of questions to include. Possible values are: Fill-in-the-Blank, Multiple Choice Question, True/False.",
    )


class ConnectRequest(BaseModel):
    briefs: list[Artifact]
    parsed_outline: ParsedOutline
    config: ConnectConfig


######## reviewer models


@enum.unique
class ReviewModule(str, enum.Enum):
    brief = "brief"
    test_yourself = "test_yourself"
    general = "general"  # For other modules without specific rules


class ReviewRequest(BaseModel):
    """Request model for content review"""

    content: str = Field(..., description="The content to be reviewed", min_length=1)
    module: ReviewModule = Field(
        default=ReviewModule.general, description="The module type to determine which validation rules to apply"
    )
    source: Optional[Union[SourceDocument, List[SourceDocument]]] = Field(
        default=None, description="Source document(s) for coverage validation (optional, recommended for brief module)"
    )




#### Generated content with current code: 
data: {"event":"on_progress_update","chunk":"Step1/7 : Generating learning objectives..."}

data: {"event":"on_progress_update","chunk":"Step2/7 : Generating question stems..."}

data: {"event":"on_progress_update","chunk":"Step3/7 : Identifying correct answers..."}

data: {"event":"on_progress_update","chunk":"Step4/7 : Generating distractors..."}

data: {"event":"on_progress_update","chunk":"Step5/7 : Reducing options..."}

data: {"event":"on_progress_update","chunk":"Step6/7 : Providing feedback..."}

data: {"event":"on_progress_update","chunk":"Step7/7: Formatting generated questions..."}

data: {"event":"on_rewrite_artifact","chunk":"## Objective 1: Explain the motivations and potential benefits driving central banks to explore the issuance of Central Bank Digital Currencies (CBDCs).\n\n### Question 1: True/False. \nWhich of the following statements reflect central banks' motivations for exploring CBDCs?\n- [Yes/No] Ensuring continued access to risk-free central bank money (Correct answer: Yes)\n- [Yes/No] Promoting greater diversity and competition in payment systems (Correct answer: Yes)\n- [Yes/No] Replacing commercial banks as payment providers (Correct answer: No)\n- [Yes/No] Preventing all forms of inflation in the economy (Correct answer: No)\n\nFeedback \nCentral banks are motivated to explore CBDCs to maintain public access to secure, risk-free money and to encourage competition and diversity in payment systems, especially as cash use declines. The statement about replacing commercial banks as payment providers is incorrect because CBDCs are designed to complement, not substitute, the existing banking sector. Preventing all forms of inflation is also a misconception; inflation control is a broader monetary policy issue and not a direct motivation for CBDC introduction.\n\n---\n\n### Question 2: True/False. \nWhich of the following benefits could CBDCs potentially deliver for the public and the financial system?\n- [Yes/No] Providing a secure and reliable alternative to cash as its use declines (Correct answer: Yes)\n- [Yes/No] Allowing rapid government fiscal transfers during emergencies (Correct answer: Yes)\n- [Yes/No] Making all payments anonymous and untraceable (Correct answer: No)\n- [Yes/No] Automatically guaranteeing higher interest rates for all savings (Correct answer: No)\n\nFeedback \nCBDCs can offer a secure alternative to cash and enable swift government transfers to citizens, supporting resilience in times of crisis. However, CBDCs are not intended to make all payments anonymous and untraceable; they must balance privacy with compliance and oversight. Likewise, CBDCs do not guarantee higher interest rates for all savings, as interest-bearing features are a complex policy choice and not a universal benefit.\n\n---\n\n### Question 3: Multiple-Choice-Single-Answer. \nWhat is a key reason central banks are considering the introduction of CBDCs?\n- To ensure everyone can access trustworthy digital money as cash usage falls (Correct answer)\n- To replace all commercial bank money with central bank money\n- To impose direct price controls throughout the economy\n- To remove cash from circulation entirely\n\nFeedback \nThe correct answer reflects the central banks’ goal to maintain access to safe central bank money as the use of physical cash declines. The other options are incorrect because CBDCs are not intended to substitute all commercial bank money, directly control prices, or fully eliminate cash; they are meant to coexist and support a diverse payment ecosystem.\n\n---\n\n### Question 4: Fill-the-Blank. \nComplete the following sentences about the motivations behind CBDC issuance.\n- CBDCs can help improve [financial inclusion/payment diversity/raising taxes] for people with limited access to banking services. (Correct answer: financial inclusion)\n- One motivation for CBDCs is to increase [payment resilience/interest rates/privacy] in case of disruptions to electronic networks. (Correct answer: payment resilience)\n- CBDCs are primarily designed to [raise taxes/offer privacy/replace banks] during economic downturns. (Correct answer: offer privacy)\n- CBDCs may offer [greater privacy/higher fees/zero inflation] than most private digital payment systems. (Correct answer: greater privacy)\n\nFeedback \nCBDCs are motivated by goals such as financial inclusion and payment resilience, making digital payments accessible and dependable for all, even during network disruptions. They may also offer greater privacy than most commercial digital payments, while remaining compliant with regulations. The statement about raising taxes is incorrect—CBDCs are not a tax collection mechanism and do not serve fiscal policy in this way.\n\n---\n\n## Objective 2: Identify and evaluate the key challenges, risks, and trade-offs associated with CBDC design and implementation, including financial stability, operational resilience, and technology considerations.\n\n### Question 1: True/False. \nWhich of the following statements describe challenges or risks linked to CBDC implementation?\n- [Yes/No] The risk of rapid withdrawals from banks to CBDCs causing instability (“digital runs”) (Correct answer: Yes)\n- [Yes/No] The threat of cyberattacks targeting CBDC infrastructure (Correct answer: Yes)\n- [Yes/No] CBDCs guarantee perfect financial stability at all times (Correct answer: No)\n- [Yes/No] CBDCs require no technological investment or upgrades (Correct answer: No)\n\nFeedback \nCBDCs introduce new challenges, such as the risk of digital runs that could destabilise banks and the need for robust cyber security to protect the digital infrastructure. It is incorrect to think that CBDCs guarantee perfect financial stability or require no technological investment. In reality, their introduction necessitates careful planning, significant investment, and ongoing risk management.\n\n---\n\n### Question 2: True/False. \nWhich of the following are trade-offs central banks must consider when designing a CBDC?\n- [Yes/No] Balancing transaction speed with robust security measures (Correct answer: Yes)\n- [Yes/No] Ensuring universal access while managing infrastructure costs (Correct answer: Yes)\n- [Yes/No] Focusing only on high fees to prevent overuse (Correct answer: No)\n- [Yes/No] Ignoring stakeholder input in the design process (Correct answer: No)\n\nFeedback \nCentral banks must balance rapid transaction settlement with the need for strong security, and strive for universal access without incurring unsustainable costs. High user fees and ignoring stakeholder feedback are not valid trade-offs—in fact, high fees can undermine inclusion and stakeholder engagement is critical to a successful CBDC design.\n\n---\n\n### Question 3: Multiple-Choice-Single-Answer. \nWhat is a major risk central banks face if a CBDC is widely adopted quickly by the public?\n- Banks may face liquidity challenges due to large-scale transfers to CBDC accounts (Correct answer)\n- CBDCs will automatically increase bank profits\n- All payments will become anonymous by default\n- System resilience will always improve with rapid CBDC adoption\n\nFeedback \nA rapid shift of funds into CBDCs can threaten the liquidity of commercial banks, posing risks to financial stability. The incorrect options reflect common misconceptions: CBDCs do not automatically boost bank profits, make all payments anonymous, or guarantee improved system resilience without careful design.\n\n---\n\n### Question 4: Fill-the-Blank. \nComplete the following sentences describing risks or challenges associated with CBDCs.\n- A sudden shift of deposits from banks to CBDC could lead to a [digital run/interest rate cap/physical theft] (Correct answer: digital run)\n- Heavy use of foreign CBDCs could result in [digital dollarisation/unlimited access/cyber risk], affecting monetary control. (Correct answer: digital dollarisation)\n- CBDCs are vulnerable to [cyber risk/physical theft/unlimited access]. (Correct answer: cyber risk)\n- Protecting CBDCs from [cyber risk/physical theft/cash withdrawal delays] is a critical challenge for central banks. (Correct answer: cyber risk)\n\nFeedback \nDigital runs and digital dollarisation are real concerns for central banks, as they can undermine domestic monetary policy and financial stability. Cyber risk is a major challenge because digital systems are inherently vulnerable to hacking and fraud. Physical theft is a concern for cash, not digital currencies, so this statement is incorrect.\n\n---\n\n## Objective 3: Describe the foundational principles, core features, and technological requirements central banks should consider when designing and deploying a CBDC.\n\n### Question 1: True/False. \nWhich of the following statements align with the core principles guiding CBDC design?\n- [Yes/No] CBDCs should not undermine financial or monetary stability (“do no harm”) (Correct answer: Yes)\n- [Yes/No] CBDCs should encourage innovation and improve payment efficiency (Correct answer: Yes)\n- [Yes/No] CBDCs should replace all forms of money immediately (Correct answer: No)\n- [Yes/No] CBDCs must always be interest-bearing (Correct answer: No)\n\nFeedback \nSound CBDC design is anchored in principles like “do no harm” and fostering innovation and efficiency. The idea that CBDCs should instantly replace all other forms of money or must always pay interest is incorrect—central banks aim for coexistence and flexibility in how CBDCs are designed and used.\n\n---\n\n### Question 2: True/False. \nWhich of the following are considered essential technological features for a robust CBDC platform?\n- [Yes/No] Ability to process high transaction volumes efficiently (scalability) (Correct answer: Yes)\n- [Yes/No] Use of strong security measures such as encryption and tamper-resistant hardware (Correct answer: Yes)\n- [Yes/No] Providing only offline payment options with no online capability (Correct answer: No)\n- [Yes/No] Limiting access to the platform to banks only (Correct answer: No)\n\nFeedback \nScalability and strong security are critical for a CBDC platform to serve large populations and withstand cyber threats. Limiting the platform to offline use or restricting access to banks only undermines the accessibility and utility of a CBDC for the general public.\n\n---\n\n### Question 3: Multiple-Choice-Single-Answer. \nWhich principle is most important for maintaining public trust in a CBDC?\n- Ensuring that the CBDC does not compromise the stability of the financial system (Correct answer)\n- Guaranteeing that CBDC transactions are always anonymous\n- Eliminating all cash transactions immediately\n- Maximising complexity in the CBDC’s design\n\nFeedback \nPublic trust depends on the CBDC supporting financial and monetary stability. The other options are incorrect because absolute anonymity is neither feasible nor desirable for compliance, eliminating cash could harm accessibility, and unnecessary complexity tends to reduce user confidence and adoption.\n\n---\n\n### Question 4: Fill-the-Blank. \nComplete the following sentences about the key features and design principles of CBDCs.\n- The system must provide [instant settlement/centralisation/high transaction fees] for user convenience. (Correct answer: instant settlement)\n- Legal [robustness/inflexibility/interest rates] is required for the central bank to issue CBDCs confidently. (Correct answer: robustness)\n- CBDCs should be [inflexible/convertible/adaptable] to new technology developments. (Correct answer: adaptable)\n- [Interoperability/centralisation/cash withdrawal delays] ensures smooth transfers between banks and digital wallets. (Correct answer: interoperability)\n\nFeedback \nInstant settlement and legal robustness are critical features for a successful CBDC. Interoperability ensures that users can transfer funds seamlessly across platforms, supporting inclusion and efficiency. Inflexibility to new technology developments is a disadvantage, as CBDCs must be adaptable to evolving needs and innovations."}